{
    "docs": [
        {
            "location": "/", 
            "text": "Coding for Journalists\n\n\nThis class is an evolving introduction to coding and the Python programming language for journalists. In addition to a tour of the fundamentals, it spans four basic projects to get you started.\n\n\nThe first version of this course happened at the \n2015 IRE Conference in Philadelphia\n; the repository and associated tasks have been updated throughout the summer.\n\n\nA few things to note before we get rolling:\n\n\n\n\nThis guide and all documentation live at \ncoding-for-journalists.rtfd.org\n\n\nThe GitHub repository that includes all code is available from \ngithub.com/ireapps/coding-for-journalists\n\n\nA good place to raise issues with the code or ask specific questions about the code is \nalso on GitHub\n\n\nEmail\n IRE Training Director Alex Richards, the primary author of this course, or \ncontact him on Twitter\n\n\n\n\nBecause of the pace of this class and limited amount of time available, we won't be able to easily accommodate attendees who prefer to use their own laptops during the session. \n\n\nEach task we'll tackle has (at least) two files: the one for writing code in and a version with \"_done\" appended to the name that's already been completed. Since there won't be enough time to get through every single one, you can circle back afterward, fetch these files from GitHub and work through the exercises on your own.\n\n\nRequirements\n\n\nThis is designed for people who have some grounding in data journalism already and experience with spreadsheets and database managers. It's helpful if you understand Excel functions, for example, and some basic SQL.\n\n\nYou will likely struggle if you don't know how to navigate the computer's command line, too; it involves moving between folders, running scripts and issuing commands to a Python interpreter.\n\n\nHere's what the next few hours have in store:\n\n\n1_start\n\n\nA whirlwind tour of Python's data types, variables, basic functionality and loops. We'll run a script in the iPython interactive interpreter to load a variety of variables and then start messing with them.\n\n\n2_web_scrape\n\n\nFetching data from the web was one of programming's original beachheads in the journalism world. We're going to grab a data table from a website and turn it into a delimited text file to use in a spreadsheet or database manager.\n\n\nThis is a task one could arguably accomplish using Excel's \"import from web\" feature, so we're going to take it one step further: we'll alter our script to drill into additional detail pages and automatically extract more columns of data for our text file.\n\n\n3_parse_addresses\n\n\nData don't always arrive in a nice, neat table. We have hundreds of addresses to parse into a format that will work in Excel or a database manager, and Python is going to help us make it happen. We'll write a script that dices it all and puts everything in its proper place -- one line for one location.\n\n\n4_make_function\n\n\nIn this quick project, we'll modify the address parsing script we wrote in the previous exercise, turning it into a reusable function that we can apply to future address lists that arrive in the same problematic format.\n\n\n5_geocode\n\n\nGeocoding is one of those perennial data journalism problems that's gotten easier in some ways over the years, yet harder in others. While having a street address is great, having a latitude and longitude is better. We'll take the poorly formatted addresses we coaxed into a flat file and march them one at a time through an online geocoding service using a handy Python library called \ngeopy\n.", 
            "title": "Main"
        }, 
        {
            "location": "/#coding-for-journalists", 
            "text": "This class is an evolving introduction to coding and the Python programming language for journalists. In addition to a tour of the fundamentals, it spans four basic projects to get you started.  The first version of this course happened at the  2015 IRE Conference in Philadelphia ; the repository and associated tasks have been updated throughout the summer.  A few things to note before we get rolling:   This guide and all documentation live at  coding-for-journalists.rtfd.org  The GitHub repository that includes all code is available from  github.com/ireapps/coding-for-journalists  A good place to raise issues with the code or ask specific questions about the code is  also on GitHub  Email  IRE Training Director Alex Richards, the primary author of this course, or  contact him on Twitter   Because of the pace of this class and limited amount of time available, we won't be able to easily accommodate attendees who prefer to use their own laptops during the session.   Each task we'll tackle has (at least) two files: the one for writing code in and a version with \"_done\" appended to the name that's already been completed. Since there won't be enough time to get through every single one, you can circle back afterward, fetch these files from GitHub and work through the exercises on your own.  Requirements  This is designed for people who have some grounding in data journalism already and experience with spreadsheets and database managers. It's helpful if you understand Excel functions, for example, and some basic SQL.  You will likely struggle if you don't know how to navigate the computer's command line, too; it involves moving between folders, running scripts and issuing commands to a Python interpreter.  Here's what the next few hours have in store:  1_start  A whirlwind tour of Python's data types, variables, basic functionality and loops. We'll run a script in the iPython interactive interpreter to load a variety of variables and then start messing with them.  2_web_scrape  Fetching data from the web was one of programming's original beachheads in the journalism world. We're going to grab a data table from a website and turn it into a delimited text file to use in a spreadsheet or database manager.  This is a task one could arguably accomplish using Excel's \"import from web\" feature, so we're going to take it one step further: we'll alter our script to drill into additional detail pages and automatically extract more columns of data for our text file.  3_parse_addresses  Data don't always arrive in a nice, neat table. We have hundreds of addresses to parse into a format that will work in Excel or a database manager, and Python is going to help us make it happen. We'll write a script that dices it all and puts everything in its proper place -- one line for one location.  4_make_function  In this quick project, we'll modify the address parsing script we wrote in the previous exercise, turning it into a reusable function that we can apply to future address lists that arrive in the same problematic format.  5_geocode  Geocoding is one of those perennial data journalism problems that's gotten easier in some ways over the years, yet harder in others. While having a street address is great, having a latitude and longitude is better. We'll take the poorly formatted addresses we coaxed into a flat file and march them one at a time through an online geocoding service using a handy Python library called  geopy .", 
            "title": "Coding for Journalists"
        }, 
        {
            "location": "/task1/", 
            "text": "1_start\n\n\nThis is a crash course in some of Python's major data types and and how to tame them. We'll be doing things like mashing strings together, running through items in a list and defining very simple functions.\n\n\nWe'll be using iPython's interactive interpreter, which means we have access to a few extra features (which iPython modestly calls \nmagic functions\n).\n\n\nBut first we have to fetch all these files. Using git and GitHub is a little bit outside the scope of this class (at the moment), so we'll download a \nzipped copy of the repo\n, unzip it, and navigate to it using PowerShell.\n\n\nThis exercise has three files:\n\n\n\n\n\n\nvar.py\n: A Python script with some variables of different types like integers, lists and dictionaries.\n\n\n\n\n\n\nexercises.py\n: A file that gives a list of exercises in the form of comments; guidance on how to manipulate the variables in \nvar.py\n. It's also the place we can write code to save for future reference. Nearly everything we do in this task will use iPython.\n\n\n\n\n\n\nexercises_done.py\n: Same as above, but with all the code filled in.\n\n\n\n\n\n\nOpening iPython is as easy as typing \nipython\n into PowerShell.\n\n\nTo get everything from \nvar.py\n queued up, we can either run it from within iPython using one of the \nmagic functions\n:\n\n\n%run var.py\n\n\n\n\nOr we can use the more traditional method of importing everything defined in a script, treating it as a module:\n\n\nfrom var import *\n\n\n\n\nThis will make a little more sense as we start bringing in other Python libraries to tackle our other tasks. Either way, it's going to get us those variables defined in \nvar.py\n. We can quickly test that these variables were loaded by typing \nlucky_number\n.\n\n\nLet's say I have a longer chunk of code that I want to try out in iPython to see if it works as expected.\n\n\npresents = ['A brand new car', 'Socks']\n\nfor gift in presents:\n    if gift == 'A brand new car':\n        print gift, '\n- Oh yeah!'\n    else:\n        print gift, '\n- Meh.'\n\n\n\n\nHaving to type this line by line into the interpreter and pay attention to indentation can be a pain.\n\n\nBut I can write that block of code in a text editor instead, then select it all and copy it. Switching over to iPython, I can use the built-in paste function:\n\n\n%paste\n\n\n\n\nThis will paste the contents of my clipboard, preserving all the indentation and other white space, and execute whatever code was there. Pretty handy.\n\n\nFinally, iPython has another function that will give you a recap of commands you've typed:\n\n\n%history", 
            "title": "Getting started"
        }, 
        {
            "location": "/task1/#1_start", 
            "text": "This is a crash course in some of Python's major data types and and how to tame them. We'll be doing things like mashing strings together, running through items in a list and defining very simple functions.  We'll be using iPython's interactive interpreter, which means we have access to a few extra features (which iPython modestly calls  magic functions ).  But first we have to fetch all these files. Using git and GitHub is a little bit outside the scope of this class (at the moment), so we'll download a  zipped copy of the repo , unzip it, and navigate to it using PowerShell.  This exercise has three files:    var.py : A Python script with some variables of different types like integers, lists and dictionaries.    exercises.py : A file that gives a list of exercises in the form of comments; guidance on how to manipulate the variables in  var.py . It's also the place we can write code to save for future reference. Nearly everything we do in this task will use iPython.    exercises_done.py : Same as above, but with all the code filled in.    Opening iPython is as easy as typing  ipython  into PowerShell.  To get everything from  var.py  queued up, we can either run it from within iPython using one of the  magic functions :  %run var.py  Or we can use the more traditional method of importing everything defined in a script, treating it as a module:  from var import *  This will make a little more sense as we start bringing in other Python libraries to tackle our other tasks. Either way, it's going to get us those variables defined in  var.py . We can quickly test that these variables were loaded by typing  lucky_number .  Let's say I have a longer chunk of code that I want to try out in iPython to see if it works as expected.  presents = ['A brand new car', 'Socks']\n\nfor gift in presents:\n    if gift == 'A brand new car':\n        print gift, ' - Oh yeah!'\n    else:\n        print gift, ' - Meh.'  Having to type this line by line into the interpreter and pay attention to indentation can be a pain.  But I can write that block of code in a text editor instead, then select it all and copy it. Switching over to iPython, I can use the built-in paste function:  %paste  This will paste the contents of my clipboard, preserving all the indentation and other white space, and execute whatever code was there. Pretty handy.  Finally, iPython has another function that will give you a recap of commands you've typed:  %history", 
            "title": "1_start"
        }, 
        {
            "location": "/task2/", 
            "text": "2_web_scrape\n\n\nNow that we've familiarized ourselves with the ways Python works, we have a little bit of a foundation to build from. Nearly everything else we do today is going to be using the fundamentals from \n1_start\n to varying degrees and in different combinations to create longer scripts.\n\n\nSo let's scrape a web page. We want to collect all the data from the main table on the U.S. Nuclear Regulatory Commission's \nlist of domestic power reactor units\n.\n\n\nPython comes with a library installed that's designed specifically for reading and writing CSV files (\ncsv\n), but we're also going to need to extend Python's functionality a bit by bringing in two other libraries.\n\n\nOne is \nrequests\n -- it handles the job of playing a web browser that can fetch a web page and send back the underlying HTML. The other is \nBeautifulSoup\n, which parses the HTML into what amounts to a series of lists that we can then search, navigate and extract data from.\n\n\nWhen we get to part two, we'll use the built-in regular expressions library \nre\n to isolate some text from the detail pages and \ntime\n to keep us from swamping a government site with too many requests at once.\n\n\nA big thank you to \nAnthony DeBarros\n for allowing us to present a modified version of his web scraping example from \npython-get-started\n.\n\n\nThis exercise contains six files:\n\n\n\n\n\n\nscrape.py\n: The file we'll use to write our scraping script, following the comments.\n\n\n\n\n\n\nscrape_pt2.py\n: The file we'll use to push our scraping script further; it contains finished code for \nscrape.py\n and open spots to add code that loops through to detail pages and collects additional information.\n\n\n\n\n\n\nnrc_backup.html\n: A backup version of the main table we want to scrape in case there's a connection problem.\n\n\n\n\n\n\ntable_example.html\n: A bare bones HTML table that shows the basic tags and how they're nested, with the flourishes of a modern web page stripped away -- it's ugly.\n\n\n\n\n\n\nscrape_done.py\n: A completed and working version of \nscrape.py\n.\n\n\n\n\n\n\nscrape_pt2_done.py\n: A completed and working version of \nscrape_pt2.py\n.", 
            "title": "Scraping the web"
        }, 
        {
            "location": "/task2/#295web_scrape", 
            "text": "Now that we've familiarized ourselves with the ways Python works, we have a little bit of a foundation to build from. Nearly everything else we do today is going to be using the fundamentals from  1_start  to varying degrees and in different combinations to create longer scripts.  So let's scrape a web page. We want to collect all the data from the main table on the U.S. Nuclear Regulatory Commission's  list of domestic power reactor units .  Python comes with a library installed that's designed specifically for reading and writing CSV files ( csv ), but we're also going to need to extend Python's functionality a bit by bringing in two other libraries.  One is  requests  -- it handles the job of playing a web browser that can fetch a web page and send back the underlying HTML. The other is  BeautifulSoup , which parses the HTML into what amounts to a series of lists that we can then search, navigate and extract data from.  When we get to part two, we'll use the built-in regular expressions library  re  to isolate some text from the detail pages and  time  to keep us from swamping a government site with too many requests at once.  A big thank you to  Anthony DeBarros  for allowing us to present a modified version of his web scraping example from  python-get-started .  This exercise contains six files:    scrape.py : The file we'll use to write our scraping script, following the comments.    scrape_pt2.py : The file we'll use to push our scraping script further; it contains finished code for  scrape.py  and open spots to add code that loops through to detail pages and collects additional information.    nrc_backup.html : A backup version of the main table we want to scrape in case there's a connection problem.    table_example.html : A bare bones HTML table that shows the basic tags and how they're nested, with the flourishes of a modern web page stripped away -- it's ugly.    scrape_done.py : A completed and working version of  scrape.py .    scrape_pt2_done.py : A completed and working version of  scrape_pt2.py .", 
            "title": "2_web_scrape"
        }, 
        {
            "location": "/task3/", 
            "text": "3_parse_addresses\n\n\nIt would be great if every piece of data you came across was in a format that lent itself to easy capture. In the same vein as the text extraction from reactor detail pages in our last example, we're going to pick apart an HTML file of licensed payday lenders (that's mostly text) and turn it into a flat CSV file where one row is one record.\n\n\nIn this file, addresses can span three, four or five lines. Sometimes it's on four lines because a lender does business in Illinois under another name; in others, it's because the lender operates out of a suite, room or building stored on a line separate from the street address. This means that our script needs to behave four different ways depending on how many lines it encounters for each address, and we'll switch among those behaviors with \nif/elif\n syntax.\n\n\nWe'll again use \nBeautifulSoup\n, but primarily to break out the portion of the file we want to capture for the resulting CSV.\n\n\nThis exercise has three files:\n\n\n\n\n\n\npayday.py\n: The file we'll use to write our address parser, following the comments.\n\n\n\n\n\n\npayday_lenders.html\n: A simple HTML file that lists nearly 500 payday lenders licensed to do business in Illinois. Their addresses are split across multiple lines.\n\n\n\n\n\n\npayday_done.py\n: A completed and working version of \npayday.py\n.", 
            "title": "Parsing text"
        }, 
        {
            "location": "/task3/#395parse_addresses", 
            "text": "It would be great if every piece of data you came across was in a format that lent itself to easy capture. In the same vein as the text extraction from reactor detail pages in our last example, we're going to pick apart an HTML file of licensed payday lenders (that's mostly text) and turn it into a flat CSV file where one row is one record.  In this file, addresses can span three, four or five lines. Sometimes it's on four lines because a lender does business in Illinois under another name; in others, it's because the lender operates out of a suite, room or building stored on a line separate from the street address. This means that our script needs to behave four different ways depending on how many lines it encounters for each address, and we'll switch among those behaviors with  if/elif  syntax.  We'll again use  BeautifulSoup , but primarily to break out the portion of the file we want to capture for the resulting CSV.  This exercise has three files:    payday.py : The file we'll use to write our address parser, following the comments.    payday_lenders.html : A simple HTML file that lists nearly 500 payday lenders licensed to do business in Illinois. Their addresses are split across multiple lines.    payday_done.py : A completed and working version of  payday.py .", 
            "title": "3_parse_addresses"
        }, 
        {
            "location": "/task4/", 
            "text": "4_make_function\n\n\nThis is a pretty quick task -- the next time we have to deal with a list from the same agency, we shouldn't have to spend time rewriting our code from scratch or even go back to revise it to handle a new file. We have something that works, so let's turn it into a function we can call whenever we need to parse addresses for a list of financial licensees.\n\n\nThis exercise contains five files:\n\n\npayday_parser.py\n: Our parser from \n3_parse_addresses\n. We'll turn the existing work into a function and generalize it a bit to handle a file that's not specifically the list of licensed payday lenders.\n\n\nconsumer_installment.html\n: Another listing from the state of Illinois, but this time it encompasses more than 1,000 licensed consumer installment lenders.\n\n\ncall_function.py\n: A script we'll write to call the parser function from \npayday_parser.py\n and direct it toward our HTML file.\n\n\npayday_parser_done.py\n: A completed and working version of \npayday_parser.py\n.\n\n\ncall_function_done.py\n: A completed and working version of \ncall_function.py\n.", 
            "title": "Making functions"
        }, 
        {
            "location": "/task4/#495make_function", 
            "text": "This is a pretty quick task -- the next time we have to deal with a list from the same agency, we shouldn't have to spend time rewriting our code from scratch or even go back to revise it to handle a new file. We have something that works, so let's turn it into a function we can call whenever we need to parse addresses for a list of financial licensees.  This exercise contains five files:  payday_parser.py : Our parser from  3_parse_addresses . We'll turn the existing work into a function and generalize it a bit to handle a file that's not specifically the list of licensed payday lenders.  consumer_installment.html : Another listing from the state of Illinois, but this time it encompasses more than 1,000 licensed consumer installment lenders.  call_function.py : A script we'll write to call the parser function from  payday_parser.py  and direct it toward our HTML file.  payday_parser_done.py : A completed and working version of  payday_parser.py .  call_function_done.py : A completed and working version of  call_function.py .", 
            "title": "4_make_function"
        }, 
        {
            "location": "/task5/", 
            "text": "5_geocode\n\n\nFor any kind of analysis that involves mapping, having coordinates is a must. En masse, though, they aren't always easy to come by.\n\n\nOpen-source geographic information systems like \nQGIS\n don't have built-in options to figure out a location's latitude and longitude; \nEsri\n charges for some of its online geocoding services, too.\n\n\nEnter \ngeopy\n, a Python library that's designed to interact with a slew of third-party geolocation APIs. As part of a larger script, we can read lines of address data from a CSV file, send each through one of these services and return the results.\n\n\nIn this example, we'll be using Google's geocoding service, which is good at properly interpreting an address string even when it's partially malformed or contains extraneous information. As a free service, however, it will only geocode 2,500 addresses in a 24-hour period.\n\n\nWe'll be using the CSV file we made by parsing payday lender addresses from 3_parse_addresses. Our goal at the end is to have a new CSV file with three additional fields of information:\n\n\n\n\nGoogle's match for the address\n\n\nLatitude in decimal degrees (Y coordinate)\n\n\nLongitude in decimal degrees (X coordinate)\n\n\n\n\nGoogle's free geocoder can only handle five requests per second, so we're going to use Python's time functions to slow our requests down and set up a control flow so that we're all only geocoding the first five addresses -- a condition that can be removed at your discretion if you're working through this task on your own later.\n\n\nThis exercise contains three files:\n\n\n\n\n\n\ngeocode.py\n: A script we'll write to pass addresses through Google's geocoding service. It will take the results along with our initial data fields and send them all to a new CSV file.\n\n\n\n\n\n\npayday_lenders.csv\n: Our completed CSV file from 3_parse_addresses.\n\n\n\n\n\n\ngeocode_done.py\n: A completed and working version of \ngeocode.py\n.", 
            "title": "Geocoding addresses"
        }, 
        {
            "location": "/task5/#5_geocode", 
            "text": "For any kind of analysis that involves mapping, having coordinates is a must. En masse, though, they aren't always easy to come by.  Open-source geographic information systems like  QGIS  don't have built-in options to figure out a location's latitude and longitude;  Esri  charges for some of its online geocoding services, too.  Enter  geopy , a Python library that's designed to interact with a slew of third-party geolocation APIs. As part of a larger script, we can read lines of address data from a CSV file, send each through one of these services and return the results.  In this example, we'll be using Google's geocoding service, which is good at properly interpreting an address string even when it's partially malformed or contains extraneous information. As a free service, however, it will only geocode 2,500 addresses in a 24-hour period.  We'll be using the CSV file we made by parsing payday lender addresses from 3_parse_addresses. Our goal at the end is to have a new CSV file with three additional fields of information:   Google's match for the address  Latitude in decimal degrees (Y coordinate)  Longitude in decimal degrees (X coordinate)   Google's free geocoder can only handle five requests per second, so we're going to use Python's time functions to slow our requests down and set up a control flow so that we're all only geocoding the first five addresses -- a condition that can be removed at your discretion if you're working through this task on your own later.  This exercise contains three files:    geocode.py : A script we'll write to pass addresses through Google's geocoding service. It will take the results along with our initial data fields and send them all to a new CSV file.    payday_lenders.csv : Our completed CSV file from 3_parse_addresses.    geocode_done.py : A completed and working version of  geocode.py .", 
            "title": "5_geocode"
        }, 
        {
            "location": "/next_steps/", 
            "text": "Next Steps\n\n\nIf you're curious about the different paths for installing Python and various libraries on your own computer, some excellent resources exist as part of the \nPyCAR\n repository. The \ntake-home portion\n points to several tutorials and guides that cover Mac and PC setup, how to compartmentalize projects in their own virtual environments and the use of version control.\n\n\nIf you want to use a virtualenv, we've included a (short) requirements file for \npip\n with all the non-standard libraries used and their dependencies.\n\n\nHere are stops to make as you expand your knowledge and keep practicing these news skills:\n\n\n\n\nAgain, the \nPyCAR\n repository, a daylong class taught at the 2014 and 2015 NICAR Conferences.\n\n\nAnthony Debarros' \npython-get-started\n repository and his useful \npython-snippets\n, a list of practical code examples.\n\n\nBen Welsh's updated guide to building \na web scraper in Python\n and his guide for building \na lightweight news app\n.\n\n\nLearnPython\n is an interactive tutorial that covers a lot of this same ground and more.\n\n\n\n\nVersion control\n\n\nAs you start feeling more comfortable with the basics, you may want to start using a version control setup like \ngit\n to catalog your scripts, collaborate with others and share your code with the world.\n\n\nHere are a couple of guides from NICAR presenters and other sources that may come in handy:\n\n\n\n\nTom Meagher's \ntipsheet on git and GitHub\n\n\nResources and code shared during NICAR15\n from the fine folks at GitHub \n\n\nLauren Orsini's \nguide for beginners\n\n\nGitHub's own \ncommand cheat sheet", 
            "title": "Next steps"
        }, 
        {
            "location": "/install/", 
            "text": "The ingredients for an install\n\n\nGetting to the point where you can do this at work or home can be half the battle. The good news is that it can pretty much all be had for free. Let's talk for a second about what this will require:\n\n\n\n\nA text editor\n\n\nPython\n\n\nAccess to a command line interface\n\n\npip\n\n\nvirtualenv\n\n\nvirtualenvwrapper\n\n\nA connection to the internet\n\n\n\n\nHere's what the various parts do, as well as why you need them:\n\n\nThe text editor\n allows you to write scripts for the Python interpreter in a plain text format. Something along the lines of a full word processor (think Microsoft Word or Apple's Pages) won't cut it; those are designed for presentation and resulting files will be cluttered with a bunch of elements that control text styling. Having one at your disposal is a must for writing code and great for examining data.\n\n\nPython\n is the engine of the entire affair; it's a code interpreter that's going to look at the commands you write and then faithfully execute them. At the moment this code and guide is designed around version 2.7.\n\n\nAccess to a command line interface\n in the form of the OS X terminal or Windows command prompt. It will be used to run Python scripts and access the Python interpreter.\n\n\npip\n is an external Python library that helps you manage the download and installation of packages that don't come with standard Python. There's a lot there already, sure, but people have written new modules to assist with tasks like web scraping and dealing with PDF files. It makes adding new functionality as easy as typing \npip install \nsome new package\n. \npip\n will fetch it from the internet and install it for you -- and do the same for any other packages required to make it all work correctly.\n\n\nvirtualenv\n is an external Python library that allows you to create virtual sandboxes where your scripts can live and have their own packages, completely compartmentalized from one another. It solves a problem in development where you may have conflicting package needs among different pieces of code. It also insulates you from mucking around with the core Python and \npip\n you'll be installing. When a new virtual environment is created, it springs up with its own copy of Python and \npip\n. The packages in the environment can be modified, removed and reset at will, but it will never screw with the underlying Python and \npip\n on the system, even if the environment is deleted.\n\n\nvirtualenvwrapper\n is another external Python library that just makes it easier to deal with the various virtual environments; it keeps them organized in one place, and you can easily jump in and out of environments with a few brief commands. It's important to note that the Windows command prompt has its own version (\nvirtualenvwrapper-win\n).\n\n\nA connection to the internet\n is necessary because \npip\n will be fetching packages from the web.\n\n\nOn Windows\n\n\n\n\nNote\n\n\nThis guide is for Windows 8.1. For other versions of Windows, this process should be similar.\n\n\n\n\n1. \nDownload Python 2.7\n\n\nYou'll want to download the \nmost current release of Python 2 for Windows\n; you'll likely have the best luck with the \nWindows x86 MSI installer\n.\n\n\n\n\n2. \nInstall Python 2.7\n\n\nAfter opening the installer, there are two things you'll want to include during the installation process that should make your life much easier.\n\n\nFirst, the installer will give you the option of having \npip\n ride along with the rest of the Python installation. By default, this should already be selected for you.\n\n\nSecond, the installer will give you the option to add python.exe to your PATH. All that means is that typing \npython\n at the command prompt will get you to the interpreter or give you the ability to execute a Python script, regardless of where you've navigated on your system. By default, this will \nnot\n be selected; you'll have to change it on your own.\n\n\nMake sure both of these options are selected before completing the install.\n\n\n\n\n3. \nVerify installation of Python and pip\n\n\nOpen the Windows command prompt. If you're unable to locate it in the \"Start\" menu, search for an application called \ncmd\n.\n\n\nTo check that Python was installed successfully, issue the following command:\n\n\npython --version\n\n\n\n\nIf everything went as planned, this should spit out the version number of Python you just installed. If you get an error message that reads something like \n'python' is not recognized as an internal or external command, operable program or batch file\n things have gone badly awry; Python may not have been added to your command prompt PATH, or you'll need to attempt to reinstall.\n\n\nIf all is well with Python, let's check on \npip\n:\n\n\npip list\n\n\n\n\nIf \npip\n was installed correctly along with Python, you should get a quick recap of nonstandard packages it can find. The output probably looks something like:\n\n\npip (7.0.1)\nsetuptools (16.0)\n\n\n\n\nIt may also have a message griping about an outdated version of \npip\n, but let's not worry about that right now.\n\n\n\n\nCaution\n\n\nIf the command prompt threw some kind of error at you, \npip\n may not be installed and there are a couple of things you can try. You can reinstall Python from the MSI file and make sure the option to install \npip\n is selected. It can also be installed manually by following \nthe instructions here\n.\n\n\n\n\n\n\n4. \nInstall virtualenv\n\n\nWith \npip\n, adding the \nvirtualenv\n package is as easy as typing:\n\n\npip install virtualenv\n\n\n\n\nIt should appear among pip and setuptools when you type \npip list\n and you should be able to verify the version with:\n\n\nvirtualenv --version\n\n\n\n\n\n\n5. \nInstall virtualenvwrapper-win\n\n\nYou may start to be seeing a pattern here with installation using \npip\n:\n\n\npip install virtualenvwrapper-win\n\n\n\n\n\n\nCaution\n\n\nIf you prefer to use a more robust command line interface like Windows PowerShell, note that the package \nvirtualenvwrapper-win\n won't work; try something like \nvirtualenvwrapper-powershell\n instead.\n\n\n\n\nThis wrapper just adds commands for easier interaction with \nvirtualenv\n. For example: Instead of having to navigate to an environment's \"Scripts\" folder and \nactivate\n it, typing \nworkon \nvirtual environment\n wherever you're navigated in the system achieves the same effect.\n\n\n\n\nOther ways into Python on Windows\n\n\nIn recent years IRE has been teaching Python in PC labs, and the easiest way to get everyone set up quickly has been to use the \nAnaconda distribution of Python\n, which comes with many popular nonstandard libraries already installed alongside the core program.\n\n\nThis remains an option available to you; it comes with \npip\n and has its own method of segregating projects into virtual environments.\n\n\n\n\nOn OS X\n\n\nPython comes pre-installed on OS X, which actually makes the process of getting set up properly more difficult.\n\n\nYes, more difficult.\n\n\nThe version accompanying OS X has been tinkered with by Apple, and it's responsible for other functionality on your computer. It's also likely out of date.\n\n\nThe accepted way to get around this problem is \n\n\nGetting \"Coding for Journalists\"", 
            "title": "Setting up your computer"
        }, 
        {
            "location": "/install/#the-ingredients-for-an-install", 
            "text": "Getting to the point where you can do this at work or home can be half the battle. The good news is that it can pretty much all be had for free. Let's talk for a second about what this will require:   A text editor  Python  Access to a command line interface  pip  virtualenv  virtualenvwrapper  A connection to the internet   Here's what the various parts do, as well as why you need them:  The text editor  allows you to write scripts for the Python interpreter in a plain text format. Something along the lines of a full word processor (think Microsoft Word or Apple's Pages) won't cut it; those are designed for presentation and resulting files will be cluttered with a bunch of elements that control text styling. Having one at your disposal is a must for writing code and great for examining data.  Python  is the engine of the entire affair; it's a code interpreter that's going to look at the commands you write and then faithfully execute them. At the moment this code and guide is designed around version 2.7.  Access to a command line interface  in the form of the OS X terminal or Windows command prompt. It will be used to run Python scripts and access the Python interpreter.  pip  is an external Python library that helps you manage the download and installation of packages that don't come with standard Python. There's a lot there already, sure, but people have written new modules to assist with tasks like web scraping and dealing with PDF files. It makes adding new functionality as easy as typing  pip install  some new package .  pip  will fetch it from the internet and install it for you -- and do the same for any other packages required to make it all work correctly.  virtualenv  is an external Python library that allows you to create virtual sandboxes where your scripts can live and have their own packages, completely compartmentalized from one another. It solves a problem in development where you may have conflicting package needs among different pieces of code. It also insulates you from mucking around with the core Python and  pip  you'll be installing. When a new virtual environment is created, it springs up with its own copy of Python and  pip . The packages in the environment can be modified, removed and reset at will, but it will never screw with the underlying Python and  pip  on the system, even if the environment is deleted.  virtualenvwrapper  is another external Python library that just makes it easier to deal with the various virtual environments; it keeps them organized in one place, and you can easily jump in and out of environments with a few brief commands. It's important to note that the Windows command prompt has its own version ( virtualenvwrapper-win ).  A connection to the internet  is necessary because  pip  will be fetching packages from the web.", 
            "title": "The ingredients for an install"
        }, 
        {
            "location": "/install/#on-windows", 
            "text": "Note  This guide is for Windows 8.1. For other versions of Windows, this process should be similar.   1.  Download Python 2.7  You'll want to download the  most current release of Python 2 for Windows ; you'll likely have the best luck with the  Windows x86 MSI installer .   2.  Install Python 2.7  After opening the installer, there are two things you'll want to include during the installation process that should make your life much easier.  First, the installer will give you the option of having  pip  ride along with the rest of the Python installation. By default, this should already be selected for you.  Second, the installer will give you the option to add python.exe to your PATH. All that means is that typing  python  at the command prompt will get you to the interpreter or give you the ability to execute a Python script, regardless of where you've navigated on your system. By default, this will  not  be selected; you'll have to change it on your own.  Make sure both of these options are selected before completing the install.   3.  Verify installation of Python and pip  Open the Windows command prompt. If you're unable to locate it in the \"Start\" menu, search for an application called  cmd .  To check that Python was installed successfully, issue the following command:  python --version  If everything went as planned, this should spit out the version number of Python you just installed. If you get an error message that reads something like  'python' is not recognized as an internal or external command, operable program or batch file  things have gone badly awry; Python may not have been added to your command prompt PATH, or you'll need to attempt to reinstall.  If all is well with Python, let's check on  pip :  pip list  If  pip  was installed correctly along with Python, you should get a quick recap of nonstandard packages it can find. The output probably looks something like:  pip (7.0.1)\nsetuptools (16.0)  It may also have a message griping about an outdated version of  pip , but let's not worry about that right now.   Caution  If the command prompt threw some kind of error at you,  pip  may not be installed and there are a couple of things you can try. You can reinstall Python from the MSI file and make sure the option to install  pip  is selected. It can also be installed manually by following  the instructions here .    4.  Install virtualenv  With  pip , adding the  virtualenv  package is as easy as typing:  pip install virtualenv  It should appear among pip and setuptools when you type  pip list  and you should be able to verify the version with:  virtualenv --version   5.  Install virtualenvwrapper-win  You may start to be seeing a pattern here with installation using  pip :  pip install virtualenvwrapper-win   Caution  If you prefer to use a more robust command line interface like Windows PowerShell, note that the package  virtualenvwrapper-win  won't work; try something like  virtualenvwrapper-powershell  instead.   This wrapper just adds commands for easier interaction with  virtualenv . For example: Instead of having to navigate to an environment's \"Scripts\" folder and  activate  it, typing  workon  virtual environment  wherever you're navigated in the system achieves the same effect.   Other ways into Python on Windows  In recent years IRE has been teaching Python in PC labs, and the easiest way to get everyone set up quickly has been to use the  Anaconda distribution of Python , which comes with many popular nonstandard libraries already installed alongside the core program.  This remains an option available to you; it comes with  pip  and has its own method of segregating projects into virtual environments.", 
            "title": "On Windows"
        }, 
        {
            "location": "/install/#on-os-x", 
            "text": "Python comes pre-installed on OS X, which actually makes the process of getting set up properly more difficult.  Yes, more difficult.  The version accompanying OS X has been tinkered with by Apple, and it's responsible for other functionality on your computer. It's also likely out of date.  The accepted way to get around this problem is", 
            "title": "On OS X"
        }, 
        {
            "location": "/install/#getting-coding-for-journalists", 
            "text": "", 
            "title": "Getting \"Coding for Journalists\""
        }
    ]
}